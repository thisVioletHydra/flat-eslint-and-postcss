const rules = {
  'style/array-bracket-newline': [1, 'consistent'],
  'style/func-call-spacing': [1, 'never'],
  'style/semi': [1, 'always'],
  'style/array-bracket-spacing': [1, 'never'],
  'style/arrow-parens': [1, 'always'],
  'style/arrow-spacing': [1, { before: true, after: true }],
  'style/block-spacing': [1, 'always'],
  'style/brace-style': [1, '1tbs', { allowSingleLine: false }],
  'style/comma-dangle': [1, 'always-multiline'],
  'style/eol-last': [1, 'never'],
  'style/indent': [1, 2,
    Object.assign({
      ArrayExpression: 1,
      CallExpression: {
        arguments: 1,
      },
      flatTernaryExpressions: false,
      FunctionDeclaration: {
        body: 1,
        parameters: 1,
      },
      FunctionExpression: {
        body: 1,
        parameters: 1,
      },
      ignoreComments: false,
      ignoredNodes: [
        'TemplateLiteral *',
        'JSXElement',
        'JSXElement > *',
        'JSXAttribute',
        'JSXIdentifier',
        'JSXNamespacedName',
        'JSXMemberExpression',
        'JSXSpreadAttribute',
        'JSXExpressionContainer',
        'JSXOpeningElement',
        'JSXClosingElement',
        'JSXFragment',
        'JSXOpeningFragment',
        'JSXClosingFragment',
        'JSXText',
        'JSXEmptyExpression',
        'JSXSpreadChild',
        'TSUnionType',
        'TSIntersectionType',
        'TSTypeParameterInstantiation',
        'FunctionExpression > .params[decorators.length > 0]',
        'FunctionExpression > .params > :matches(Decorator, :not(:first-child))',
        'ClassBody.body > PropertyDefinition[decorators.length > 0] > .key',
      ],
      ImportDeclaration: 1,
      MemberExpression: 1,
      ObjectExpression: 1,
      offsetTernaryExpressions: true,
      outerIIFEBody: 1,
      SwitchCase: 1,
      VariableDeclarator: 1,
    }, {
      FunctionDeclaration: { body: 1, parameters: 2 },
      flatTernaryExpressions: true,
    })],
  'style/max-statements-per-line': [1, { max: 1 }],
  'style/no-multiple-empty-lines': [1, { max: 1, maxEOF: 0, maxBOF: 0 }],
  'style/no-tabs': [1],
  'style/nonblock-statement-body-position': [1, 'beside'],
  'style/object-curly-newline': [0],
  'style/one-var-declaration-per-line': [1, 'always'],
  'style/operator-linebreak': [1, 'before'],
  'style/padded-blocks': [1, 'never'],
  'style/padding-line-between-statements': [1, { blankLine: 'always', prev: '*', next: 'return' }],
  'style/space-before-blocks': [1, 'always'],
  'style/space-before-function-paren': [1, 'never'],
  'style/space-in-parens': [1, 'never'],
  'style/space-infix-ops': [1],
  'style/switch-colon-spacing': [1, { after: true, before: false }],
  'style/function-call-spacing': [1, 'never'],
  'style/newline-per-chained-call': [0],
  'style/no-confusing-arrow': [2, { allowParens: true, onlyOneSimpleParam: false }],
  'style/no-extra-semi': [1],
  'style/no-floating-decimal': [1],
  'style/no-mixed-operators': [2, {
    groups: [
      ['+', '-', '*', '/', '%', '**'],
      ['&', '|', '^', '~', '<<', '>>', '>>>'],
      ['==', '!=', '===', '!==', '>', '>=', '<', '<='],
      ['&&', '||'],
      ['in', 'instanceof'],
    ],
    allowSamePrecedence: true,
  }],
  'style/no-whitespace-before-property': [1],
  'style/yield-star-spacing': [1, 'after'],
  'style/implicit-arrow-linebreak': [1, 'beside'],
  'style/indent-binary-ops': [1, 2],
};

export function stylisticRules() {
  return {
    rules,
  };
}